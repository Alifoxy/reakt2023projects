{"ast":null,"code":"import { appendErrors as e } from \"react-hook-form\";\nimport { toNestError as r, validateFieldsNatively as t } from \"@hookform/resolvers\";\nvar n = function (n, o, a) {\n  return void 0 === o && (o = {\n    abortEarly: !1\n  }), void 0 === a && (a = {}), function (i, s, u) {\n    try {\n      var c = function () {\n          return l.error ? {\n            values: {},\n            errors: r((n = l.error, o = !u.shouldUseNativeValidation && \"all\" === u.criteriaMode, n.details.length ? n.details.reduce(function (r, t) {\n              var n = t.path.join(\".\");\n              if (r[n] || (r[n] = {\n                message: t.message,\n                type: t.type\n              }), o) {\n                var a = r[n].types,\n                  i = a && a[t.type];\n                r[n] = e(n, o, r, t.type, i ? [].concat(i, t.message) : t.message);\n              }\n              return r;\n            }, {}) : {}), u)\n          } : (u.shouldUseNativeValidation && t({}, u), {\n            errors: {},\n            values: l.value\n          });\n          var n, o;\n        },\n        v = Object.assign({}, o, {\n          context: s\n        }),\n        l = {},\n        f = function () {\n          if (\"sync\" === a.mode) l = n.validate(i, v);else {\n            var e = function (e, r) {\n              try {\n                var t = e();\n              } catch (e) {\n                return r(e);\n              }\n              return t && t.then ? t.then(void 0, r) : t;\n            }(function () {\n              return Promise.resolve(n.validateAsync(i, v)).then(function (e) {\n                l.value = e;\n              });\n            }, function (e) {\n              l.error = e;\n            });\n            if (e && e.then) return e.then(function () {});\n          }\n        }();\n      return Promise.resolve(f && f.then ? f.then(c) : c());\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n};\nexport { n as joiResolver };","map":{"version":3,"mappings":";;AAKA,IA+BaA,IACX,UACEC,GACAC,GAGAC;EAAAA,kBAHAD,UAAgB;IACdE,aAAY;EAAA,eAEdD,UAAkB,eAEbE,GAAQC,GAASC;IAAAA;MAAAA;UAgBtB,OAAIC,EAAOC,QACF;YACLJ,QAAQ;YACRK,QAAQC,GAzDdF,IA2DUD,EAAOC,OA1DjBG,KA2DWL,EAAQM,6BACkB,UAAzBN,EAAQO,cA1DpBL,EAAMM,QAAQC,SACVP,EAAMM,QAAQE,OAAmC,UAACC,GAAUT;cAC1D,IAAMU,IAAQV,EAAMW,KAAKC,KAAK;cAM9B,IAJKH,EAASC,OACZD,EAASC,KAAS;gBAAEG,SAASb,EAAMa;gBAASC,MAAMd,EAAMc;cAAAA,IAGtDX,GAA0B;gBAC5B,IAAMY,IAAQN,EAASC,GAAOK;kBACxBC,IAAWD,KAASA,EAAMf,EAAMc;gBAEtCL,EAASC,KAASO,EAChBP,GACAP,GACAM,GACAT,EAAMc,MACNE,IACK,GAAgBE,OAAOF,GAAsBhB,EAAMa,WACpDb,EAAMa;cAAAA;cAId,OAAOJ;YAAAA,GACN,MACH,KAmCIX;UAAAA,KAKNA,EAAQM,6BAA6Be,EAAuB,IAAIrB,IAEzD;YACLG,QAAQ;YACRL,QAAQG,EAAOqB;UAAAA;UAzEI,IACvBpB,GACAG;QAAAA;QAsCQkB,IAAiBC,OAAOC,OAAO,IAAI9B,GAAe;UACtDI;QAAAA;QAGEE,IAA8B;QAAAyB;UAAA,IACL,WAAzB9B,EAAgB+B,MAClB1B,IAASP,EAAOkC,SAAS9B,GAAQyB;YAAAA;cAAAA;gBAAAA;cAAAA;gBAAAA;cAAAA;cAAAA;YAAAA;cAAAA,uBAGV7B,EAAOmC,cAAc/B,GAAQyB;gBAAlDtB,EAAOqB;cAAAA;YAAAA,aACAQ;cACP7B,EAAOC,QAAQ4B;YAAAA;YAAAA;UAAAA;QAAAA;MAAAA;IAAAA,CAnBrB;MAAA;IAAA;EAAA;AAAA;AAAA","names":["joiResolver","schema","schemaOptions","resolverOptions","abortEarly","values","context","options","result","error","errors","toNestError","validateAllFieldCriteria","shouldUseNativeValidation","criteriaMode","details","length","reduce","previous","_path","path","join","message","type","types","messages","appendErrors","concat","validateFieldsNatively","value","_schemaOptions","Object","assign","f","mode","validate","validateAsync","e"],"sources":["C:\\Users\\Инна\\reakt2023\\node_modules\\@hookform\\resolvers\\joi\\src\\joi.ts"],"sourcesContent":["import { appendErrors, FieldError } from 'react-hook-form';\nimport { toNestError, validateFieldsNatively } from '@hookform/resolvers';\nimport type { ValidationError } from 'joi';\nimport { Resolver } from './types';\n\nconst parseErrorSchema = (\n  error: ValidationError,\n  validateAllFieldCriteria: boolean,\n) =>\n  error.details.length\n    ? error.details.reduce<Record<string, FieldError>>((previous, error) => {\n        const _path = error.path.join('.');\n\n        if (!previous[_path]) {\n          previous[_path] = { message: error.message, type: error.type };\n        }\n\n        if (validateAllFieldCriteria) {\n          const types = previous[_path].types;\n          const messages = types && types[error.type!];\n\n          previous[_path] = appendErrors(\n            _path,\n            validateAllFieldCriteria,\n            previous,\n            error.type,\n            messages\n              ? ([] as string[]).concat(messages as string[], error.message)\n              : error.message,\n          ) as FieldError;\n        }\n\n        return previous;\n      }, {})\n    : {};\n\nexport const joiResolver: Resolver =\n  (\n    schema,\n    schemaOptions = {\n      abortEarly: false,\n    },\n    resolverOptions = {},\n  ) =>\n  async (values, context, options) => {\n    const _schemaOptions = Object.assign({}, schemaOptions, {\n      context,\n    });\n\n    let result: Record<string, any> = {};\n    if (resolverOptions.mode === 'sync') {\n      result = schema.validate(values, _schemaOptions);\n    } else {\n      try {\n        result.value = await schema.validateAsync(values, _schemaOptions);\n      } catch (e) {\n        result.error = e;\n      }\n    }\n\n    if (result.error) {\n      return {\n        values: {},\n        errors: toNestError(\n          parseErrorSchema(\n            result.error,\n            !options.shouldUseNativeValidation &&\n              options.criteriaMode === 'all',\n          ),\n          options,\n        ),\n      };\n    }\n\n    options.shouldUseNativeValidation && validateFieldsNatively({}, options);\n\n    return {\n      errors: {},\n      values: result.value,\n    };\n  };\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}